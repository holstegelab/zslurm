#!/usr/bin/env python
import argparse
import json
import os
import re
import shlex
import subprocess
import sys
from collections import defaultdict, OrderedDict


def _read_input(args):
    if args.input == "-":
        return sys.stdin.read()
    if args.input:
        with open(args.input, "r", encoding="utf-8") as fh:
            return fh.read()
    try:
        p = subprocess.run([
            "scontrol", "--json", "show", "nodes", "-o"
        ], check=False, capture_output=True, text=True)
        if p.returncode == 0:
            s = p.stdout.strip()
            if s.startswith("{"):
                return ("__JSON__\n" + s)
    except Exception:
        pass
    p = subprocess.run(["scontrol", "show", "nodes", "-o"], check=False, capture_output=True, text=True)
    if p.returncode != 0:
        sys.stderr.write("failed to run scontrol show nodes -o\n")
        sys.exit(2)
    return p.stdout


def _parse_state(state):
    if state is None:
        return "UNKNOWN"
    if isinstance(state, (list, tuple, set)):
        vals = []
        for x in state:
            if isinstance(x, dict):
                xv = x.get("current_state") or x.get("state") or x.get("State") or ""
            else:
                xv = x
            if xv is None:
                continue
            vals.append(str(xv))
        state = "+".join(vals)
    elif isinstance(state, dict):
        state = state.get("current_state") or state.get("state") or state.get("State") or ""
    s = str(state)
    s = s.strip()
    if not s:
        return "UNKNOWN"
    s = s.split()[0]
    s = s.split("(")[0]
    s = s.split("+")[0]
    s = s.rstrip("*!")
    s = s.upper()
    if not s:
        s = "UNKNOWN"
    return s


def _parse_features(v):
    if not v:
        return set()
    v = str(v).strip()
    if v in ("(null)", "N/A", "none", "None"):
        return set()
    out = set()
    for part in re.split(r"[,\s]+", v):
        part = part.strip()
        if part:
            out.add(part)
    return out


def _parse_partitions(v):
    if not v:
        return []
    v = str(v).strip()
    if v in ("(null)", "N/A", "none", "None"):
        return []
    parts = [p.strip() for p in v.split(",") if p.strip()]
    return parts if parts else []


def _parse_float(v):
    try:
        x = float(v)
        if x == x:
            return x
        return None
    except Exception:
        return None


def _parse_int(v):
    try:
        return int(float(v))
    except Exception:
        return None


def _finalize_kv_tokens(tokens):
    out = []
    buf_k = None
    buf_v = []
    for t in tokens:
        if "=" in t:
            if buf_k is not None:
                out.append((buf_k, " ".join(buf_v)))
            k, v = t.split("=", 1)
            buf_k, buf_v = k, [v]
        else:
            if buf_k is None:
                continue
            buf_v.append(t)
    if buf_k is not None:
        out.append((buf_k, " ".join(buf_v)))
    return out


def parse_scontrol_text(s):
    s = s.replace("\u00A0", " ")
    lines = [ln.strip() for ln in s.splitlines() if ln.strip()]
    nodes = []
    cur = []
    for ln in lines:
        parts = ln.split()
        if any(p.startswith("NodeName=") for p in parts) and cur:
            kvs = _finalize_kv_tokens(cur)
            nodes.append(dict(kvs))
            cur = []
        cur.extend(parts)
    if cur:
        kvs = _finalize_kv_tokens(cur)
        nodes.append(dict(kvs))
    out = []
    for nd in nodes:
        name = nd.get("NodeName") or nd.get("NodeHostName") or ""
        parts = _parse_partitions(nd.get("Partitions"))
        state = _parse_state(nd.get("State"))
        feats = _parse_features(nd.get("AvailableFeatures"))
        cpu_load = _parse_float(nd.get("CPULoad"))
        cpu_alloc = _parse_int(nd.get("CPUAlloc"))
        cpu_tot = _parse_int(nd.get("CPUTot"))
        out.append({
            "name": name,
            "partitions": parts,
            "state": state,
            "features": feats,
            "cpu_load": cpu_load,
            "cpu_alloc": cpu_alloc,
            "cpu_tot": cpu_tot,
        })
    return out


def parse_scontrol_json(s):
    try:
        data = json.loads(s)
    except Exception:
        return None
    nodes = data.get("nodes") or data.get("Nodes") or []
    out = []
    for nd in nodes:
        name = nd.get("name") or nd.get("NodeName") or nd.get("hostname") or ""
        parts = nd.get("partitions") or nd.get("Partitions") or []
        if isinstance(parts, str):
            parts = _parse_partitions(parts)
        else:
            parts = [str(p) for p in parts if str(p).strip()]
        state_obj = nd.get("state") or {}
        if isinstance(state_obj, dict):
            state = state_obj.get("current_state") or state_obj.get("state") or nd.get("State")
        else:
            state = state_obj or nd.get("State")
        state = _parse_state(state)
        feats = set()
        f = nd.get("features") or nd.get("available_features") or nd.get("AvailableFeatures")
        if isinstance(f, dict):
            av = f.get("available") or f.get("avail") or f.get("Available")
            if isinstance(av, list):
                feats = set(str(x) for x in av)
            elif isinstance(av, str):
                feats = _parse_features(av)
            else:
                feats = set()
        elif isinstance(f, list):
            feats = set(str(x) for x in f)
        elif isinstance(f, str):
            feats = _parse_features(f)
        cpu_load = nd.get("cpu_load")
        if cpu_load is None:
            cpu_load = nd.get("CPULoad")
        cpu_load = _parse_float(cpu_load)
        cpu_alloc = nd.get("alloc_cpus")
        if cpu_alloc is None:
            cpu_alloc = nd.get("CPUAlloc")
        cpu_alloc = _parse_int(cpu_alloc)
        cpu_tot = nd.get("cpus")
        if cpu_tot is None:
            cpu_tot = nd.get("CPUTot")
        cpu_tot = _parse_int(cpu_tot)
        out.append({
            "name": name,
            "partitions": parts,
            "state": state,
            "features": feats,
            "cpu_load": cpu_load,
            "cpu_alloc": cpu_alloc,
            "cpu_tot": cpu_tot,
        })
    return out


def aggregate(nodes):
    parts = {}
    all_states = set()
    for nd in nodes:
        pset = nd.get("partitions") or []
        if not pset:
            pset = ["(none)"]
        feats = nd.get("features") or set()
        has_scratch = ("scratch-node" in feats)
        for p in pset:
            key = f"{p} (scratch)" if has_scratch else f"{p} (no-scratch)"
            if key not in parts:
                parts[key] = {
                    "nodes": 0,
                    "scratch": 0,
                    "cpu_alloc": 0,
                    "cpu_tot": 0,
                    "load_sum": 0.0,
                    "load_cnt": 0,
                    "states": defaultdict(int),
                }
            ag = parts[key]
            ag["nodes"] += 1
            st = nd.get("state") or "UNKNOWN"
            all_states.add(st)
            ag["states"][st] += 1
            if has_scratch:
                ag["scratch"] += 1
            ca = nd.get("cpu_alloc")
            if isinstance(ca, int):
                ag["cpu_alloc"] += ca
            ct = nd.get("cpu_tot")
            if isinstance(ct, int):
                ag["cpu_tot"] += ct
            cl = nd.get("cpu_load")
            if isinstance(cl, (int, float)):
                ag["load_sum"] += float(cl)
                ag["load_cnt"] += 1
    return parts, sorted(all_states)


def format_rows(parts, state_cols):
    rows = []
    for p in sorted(parts.keys()):
        ag = parts[p]
        load_mean = (ag["load_sum"] / ag["load_cnt"]) if ag["load_cnt"] > 0 else None
        row = OrderedDict()
        row["PARTITION"] = p
        row["NODES"] = ag["nodes"]
        row["CPU_ALLOC"] = ag["cpu_alloc"]
        row["CPU_TOT"] = ag["cpu_tot"]
        row["CPU_LOAD_MEAN"] = (None if load_mean is None else round(load_mean, 2))
        for st in state_cols:
            row[f"STATE_{st}"] = ag["states"].get(st, 0)
        rows.append(row)
    return rows


def main():
    ap = argparse.ArgumentParser(prog="zsoccupancy", description="Summarize partition occupancy from 'scontrol show nodes'.")
    ap.add_argument("--input", default=None, help="Path to input text. Use '-' for stdin. Default: call scontrol")
    ap.add_argument("--json", dest="as_json", action="store_true", help="Output JSON instead of table")
    ap.add_argument("--parseable", action="store_true", help="Output TSV table suitable for parsing")
    args = ap.parse_args()

    raw = _read_input(args)
    nodes = None
    if raw.startswith("__JSON__\n"):
        nodes = parse_scontrol_json(raw.split("\n", 1)[1])
    else:
        try:
            maybe = parse_scontrol_json(raw)
            if isinstance(maybe, list):
                nodes = maybe
        except Exception:
            nodes = None
    if nodes is None:
        nodes = parse_scontrol_text(raw)

    parts, state_cols = aggregate(nodes)
    rows = format_rows(parts, state_cols)

    if args.as_json:
        sys.stdout.write(json.dumps(rows, indent=2) + "\n")
        return

    cols = list(rows[0].keys()) if rows else ["PARTITION","NODES","CPU_ALLOC","CPU_TOT","CPU_LOAD_MEAN"]
    scratch_rows = []
    noscratch_rows = []
    for r in rows:
        part = str(r.get("PARTITION", ""))
        if part.endswith(" (scratch)"):
            rr = OrderedDict(r)
            rr["PARTITION"] = part[: -len(" (scratch)")]
            scratch_rows.append(rr)
        elif part.endswith(" (no-scratch)"):
            rr = OrderedDict(r)
            rr["PARTITION"] = part[: -len(" (no-scratch)")]
            noscratch_rows.append(rr)
        else:
            noscratch_rows.append(r)
    def _mk_table(rs, cols):
        return [[x.get(c, "") for c in cols] for x in rs]
    scratch_rows = sorted(scratch_rows, key=lambda x: (-(float(x.get("CPU_TOT") or 0.0)), str(x.get("PARTITION",""))))
    noscratch_rows = sorted(noscratch_rows, key=lambda x: (-(float(x.get("CPU_TOT") or 0.0)), str(x.get("PARTITION",""))))
    use_pretty = not args.parseable
    tabulate_module = None
    if use_pretty:
        try:
            import tabulate as tabulate_module
        except ImportError:
            sys.stderr.write("Pretty formatting unavailable: install 'tabulate' or use --parseable\n")
            use_pretty = False
        except Exception:
            import traceback
            traceback.print_exc()
            sys.stderr.write("Pretty formatting failed; falling back to TSV. Use --parseable to suppress this message.\n")
            use_pretty = False

    if use_pretty and tabulate_module is not None:
        if scratch_rows:
            print("SCRATCH NODES")
            print(tabulate_module.tabulate(_mk_table(scratch_rows, cols), headers=cols))
            print()
        if noscratch_rows:
            print("NO-SCRATCH NODES")
            print(tabulate_module.tabulate(_mk_table(noscratch_rows, cols), headers=cols))
        return
    sys.stdout.write("\t".join(cols) + "\n")
    if scratch_rows:
        sys.stdout.write("SCRATCH NODES\n")
        for r in scratch_rows:
            vals = []
            for c in cols:
                v = r.get(c, "")
                vals.append("") if v is None else vals.append(str(v))
            sys.stdout.write("\t".join(vals) + "\n")
        sys.stdout.write("\n")
    if noscratch_rows:
        sys.stdout.write("NO-SCRATCH NODES\n")
        for r in noscratch_rows:
            vals = []
            for c in cols:
                v = r.get(c, "")
                vals.append("") if v is None else vals.append(str(v))
            sys.stdout.write("\t".join(vals) + "\n")


if __name__ == "__main__":
    try:
        main()
    except Exception:
        import traceback
        traceback.print_exc()
        sys.exit(1)
